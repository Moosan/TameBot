import { Client, GatewayIntentBits, Collection, REST, Routes, ChatInputCommandInteraction, SlashCommandBuilder } from 'discord.js';
import { config } from './config';
import { pingCommand } from './commands/ping';
import { Scheduler } from './scheduler/scheduler';

// ã‚³ãƒãƒ³ãƒ‰ã®å‹å®šç¾©
interface Command {
  data: SlashCommandBuilder;
  execute: (interaction: ChatInputCommandInteraction) => Promise<void>;
}

// Discord Bot ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ä½œæˆ
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds, // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã¨ã‚®ãƒ«ãƒ‰æƒ…å ±ã«å¿…è¦
  ],
});

// ã‚³ãƒãƒ³ãƒ‰ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
const commands = new Collection<string, Command>();
commands.set(pingCommand.data.name, pingCommand);

// Botèµ·å‹•æ™‚ã®å‡¦ç†
client.once('clientReady', async () => {
  console.log(`âœ… ${client.user?.tag} ã¨ã—ã¦ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸï¼`);

  // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²
  const rest = new REST().setToken(config.discordToken);

  try {
    console.log('ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²ä¸­...');

    await rest.put(
      Routes.applicationCommands(config.clientId),
      { body: [pingCommand.data.toJSON()] }
    );

    console.log('âœ… ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²ãŒå®Œäº†ã—ã¾ã—ãŸï¼');
  } catch (error) {
    console.error('âŒ ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ã®ç™»éŒ²ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
  }

  // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ–ï¼ˆå°†æ¥çš„ãªæ‹¡å¼µç”¨ï¼‰
  const scheduler = new Scheduler(client);
  scheduler.initialize();
});

// ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ï¼‰ã®å‡¦ç†
client.on('interactionCreate', async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  const command = commands.get(interaction.commandName);

  if (!command) {
    console.error(`ã‚³ãƒãƒ³ãƒ‰ ${interaction.commandName} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚`);
    return;
  }

  try {
    await command.execute(interaction);
  } catch (error) {
    console.error(`ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:`, error);
    const errorMessage = 'ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';

    if (interaction.replied || interaction.deferred) {
      await interaction.followUp({ content: errorMessage, ephemeral: true });
    } else {
      await interaction.reply({ content: errorMessage, ephemeral: true });
    }
  }
});

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
client.on('error', (error) => {
  console.error('Discord Bot ã‚¨ãƒ©ãƒ¼:', error);
});

process.on('unhandledRejection', (error) => {
  console.error('æœªå‡¦ç†ã®Promiseæ‹’å¦:', error);
});

// ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ï¼ˆSIGTERM / SIGINTï¼‰
let isShuttingDown = false;

function shutdown(signal: string) {
  if (isShuttingDown) return;
  isShuttingDown = true;
  console.log(`ğŸ›‘ ${signal} ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ä¸­...`);
  client.destroy();
  process.exit(0);
}

process.on('SIGTERM', () => shutdown('SIGTERM'));
process.on('SIGINT', () => shutdown('SIGINT'));

// Botã®ãƒ­ã‚°ã‚¤ãƒ³
client.login(config.discordToken);
